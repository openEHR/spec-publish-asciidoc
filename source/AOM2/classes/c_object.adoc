==== C_OBJECT CLASS

[cols="^1,2,3"]
|===
|*CLASS*
{set:cellbgcolor:lightblue}
2+^|*_C_OBJECT (abstract)_*

|*Description*
{set:cellbgcolor:lightblue}
2+|Abstract model of constraint on any kind of object node. 
{set:cellbgcolor!}

|*Inherit*
{set:cellbgcolor:lightblue}
2+|ARCHETYPE_CONSTRAINT
{set:cellbgcolor!}

|*Attributes*
{set:cellbgcolor:lightblue}
^|*Signature*
^|*Meaning*

|*1..1*
{set:cellbgcolor:lightblue}
|*rm_type_name*: `String`
{set:cellbgcolor!}
|Reference model type that this node corresponds to. 

|*0..1*
{set:cellbgcolor:lightblue}
|*occurrences*: `MULTIPLICITY_INTERVAL`
{set:cellbgcolor!}
|Occurrences of this object node in the data, under the owning attribute. Upper limit can only be greater than 1 if owning attribute has a cardinality of more than 1. +
Only set if it overrides the parent archetype in the case of specialised archetypes, or else the occurrences inferred from the underlying reference model existence and/or cardinality of the containing attribute.

|*1..1*
{set:cellbgcolor:lightblue}
|*node_id*: `String`
{set:cellbgcolor!}
|Semantic identifier of this node, used to dis-tinguish sibling nodes. All nodes must have a node_id; for nodes under a container C_ATTRIBUTE, the id must be an id-code must be defined in the archetype terminolo-gy. For valid structures, all node ids are id-codes. +
For C_PRIMITIVE_OBJECTs, it will have the special value Primitive_node_id.

|*0..1*
{set:cellbgcolor:lightblue}
|*is_deprecated*: `Boolean`
{set:cellbgcolor!}
|True if this node and by implication all sub-nodes are deprecated for use.

|*0..1*
{set:cellbgcolor:lightblue}
|*sibling_order*: `SIBLING_ORDER`
{set:cellbgcolor!}
|
|*Functions*
{set:cellbgcolor:lightblue}
^|*Signature*
^|*Meaning*

|
{set:cellbgcolor:lightblue}
|*specialisation_depth*: `Integer`
{set:cellbgcolor!}
|

|*(effected)*
{set:cellbgcolor:lightblue}
|*is_prohibited*: `Boolean`
{set:cellbgcolor!}
|True if this node (and all its sub-nodes) is a valid archetype node for its type. This function should be implemented by each subtype to perform semantic validation of itself, and then call the is_valid function in any subparts, and generate the result appropriately.

|*(effected)*
{set:cellbgcolor:lightblue}
|*has_path*: `boolean`
{set:cellbgcolor!}
|True if the relative path a_path exists at this node.

|*(effected)*
{set:cellbgcolor:lightblue}
|*path*: `String`
{set:cellbgcolor!}
|Path of this node relative to root of archetype.

|*(effected)*
{set:cellbgcolor:lightblue}
|*c_conforms_to*: `Boolean`
{set:cellbgcolor!}
|True if constraints represented by this node, ignoring any sub-parts, are narrower or the same as other.  +
Typically used during validation of special-ised archetype nodes.

|*(effected)*
{set:cellbgcolor:lightblue}
|*c_congruent_to*: `Boolean`
{set:cellbgcolor!}
|True if constraints represented by this node contain no further redefinitions with respect to the node other, with the exception of node_id redefnition in C_OBJECT nodes.  +
Typically used to test if an inherited node locally contains any constraints.

|*(effected)*
{set:cellbgcolor:lightblue}
|*is_second_order_constrained*: `Boolean`
{set:cellbgcolor!}
|

|*(effected)*
{set:cellbgcolor:lightblue}
|*is_root*: `Boolean`
{set:cellbgcolor!}
|

|*(effected)*
{set:cellbgcolor:lightblue}
|*is_leaf*: `Boolean`
{set:cellbgcolor!}
|
|===
