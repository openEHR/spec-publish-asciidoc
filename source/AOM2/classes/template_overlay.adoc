==== TEMPLATE_OVERLAY CLASS

[cols="^1,2,3"]
|===
|*CLASS*
{set:cellbgcolor:lightblue}
2+^|*TEMPLATE_OVERLAY*

|*Description*
{set:cellbgcolor:lightblue}
2+|A concrete form of the bare ARCHETYPE class, used to represent overlays in a source template. Overlays have no meta-data of their own, and are instead docu-mented by their owning template.
{set:cellbgcolor!}

|*Inherit*
{set:cellbgcolor:lightblue}
2+|ARCHETYPE
{set:cellbgcolor!}

|*Functions*
{set:cellbgcolor:lightblue}
^|*Signature*
^|*Meaning*

|*(effected)*
{set:cellbgcolor:lightblue}
|*concept_code*: `String` +
*_post-condition_*: Result.is_equal (definition.node_id)
{set:cellbgcolor!}
|The concept code of the root object of the archetype, also standing for the concept of the archetype as a whole.

|*(effected)*
{set:cellbgcolor:lightblue}
|*physical_paths*: `String`
{set:cellbgcolor!}
|Set of language-independent paths extracted from archetype. Paths obey Xpath-like syntax and are formed from alternations of C_OBJECT.node_id and C_ATTRIBUTE.rm_attribute_name values. 

|*(effected)*
{set:cellbgcolor:lightblue}
|*logical_paths*: `String`
{set:cellbgcolor!}
|Set of language-dependent paths extracted from archetype. Paths obey the same syntax as physical_paths, but with node_ids replaced by their meanings from the ontology. 

|*(effected)*
{set:cellbgcolor:lightblue}
|*specialisation_depth*: `Integer` +
*_post-condition_*: Result = terminology.specialisation_depth
{set:cellbgcolor!}
|Specialisation depth of this archetype; larger than 0 if this archetype has a parent. Derived from terminology.specialisation_depth.

|*(effected)*
{set:cellbgcolor:lightblue}
|*is_specialised*: `Boolean` +
*_post-condition_*: Result implies parent_archetype_hrid /= Void
{set:cellbgcolor!}
|True if this archetype is a specialisation of another. 

|*Invariant*
{set:cellbgcolor:lightblue}
2+|*_Inv_is_specialised_*: is_specialised
{set:cellbgcolor!}
|===
