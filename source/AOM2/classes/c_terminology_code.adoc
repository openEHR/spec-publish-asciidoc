==== C_TERMINOLOGY_CODE CLASS

[cols="^1,2,3"]
|===
|*CLASS*
{set:cellbgcolor:lightblue}
2+^|*C_TERMINOLOGY_CODE*

|*Description*
{set:cellbgcolor:lightblue}
2+|Constrainer type for instances of TERMINOLOGY_CODE. The primary expression of the constraint is in the property `tuple_constraint', and comes in 3 variations: +
* a single at-code +
* a single ac-code, representing a value-set that is defined in the archetype terminology +
* a list of at- and/or ac-codes, representing the possibilities of a tuple constraint +
The last possibility above is enabled by the merge_tuple routine, which enables the constraint of another single-valued C_TERMINOLOGY_CODE to be merged with the current one.
{set:cellbgcolor!}

|*Inherit*
{set:cellbgcolor:lightblue}
2+|C_PRIMITIVE_OBJECT
{set:cellbgcolor!}

|*Attributes*
{set:cellbgcolor:lightblue}
^|*Signature*
^|*Meaning*

|*1..1*
{set:cellbgcolor:lightblue}
|*constraint*: `String`
{set:cellbgcolor!}
|Type of individual constraint - a single string that can either be a local at-code, or a local ac-code signifying a locally defined value set. If an ac-code, assumed_value may contain an at-code from the value set of the ac-code.

|*0..1*
{set:cellbgcolor:lightblue}
|*assumed_value*: `TERMINOLOGY_CODE`
{set:cellbgcolor!}
|

|*1..1*
{set:cellbgcolor:lightblue}
|*default_value*: `TERMINOLOGY_CODE`
{set:cellbgcolor!}
|
|*Functions*
{set:cellbgcolor:lightblue}
^|*Signature*
^|*Meaning*

|
{set:cellbgcolor:lightblue}
|*value_set_expanded*: `String`
{set:cellbgcolor!}
|Effective value or value set of single constraint in tuple_constraint, mediated by terminology to expand an ac-code.

|
{set:cellbgcolor:lightblue}
|*value_set_substituted*: `Uri`
{set:cellbgcolor!}
|List of external URI(s) either substituted for local at-codes in value_set_expanded, or else an external ref-set URI substituted for the accode in value_set_id, via bindings, if they exist.

|
{set:cellbgcolor:lightblue}
|*value_set_resolved*: `TERMINOLOGY_CODE`
{set:cellbgcolor!}
|Final set of codes, which may be internal or external, to which value set is resolved. For internally defined value sets, the list is 1:1 with value_set_substituted. For external value-sets, the list is determined by a terminology service.

|
{set:cellbgcolor:lightblue}
|*valid_value*: `Boolean`
{set:cellbgcolor!}
|True if a_value is valid with respect to constraint expressed in concrete instance of this type. 

|
{set:cellbgcolor:lightblue}
|*prototype_value*: `TERMINOLOGY_CODE`
{set:cellbgcolor!}
|A generated prototype value from this constraint object.

|*(effected)*
{set:cellbgcolor:lightblue}
|*has_assumed_value*: `Boolean`
{set:cellbgcolor!}
|True if there is an assumed value.

|*(effected)*
{set:cellbgcolor:lightblue}
|*constrained_typename*: `String`
{set:cellbgcolor!}
|Generate name of native type that is constrained by this C_XXX type. For most types, it is the C_XXX typename without the 'C_', i.e. XXX. E.g. C_INTEGER -> Integer. For the date/time types the mapping is different.
|===
